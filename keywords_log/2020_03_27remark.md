# 2020.03.27 补充

p.s. 最近咕了(ーー゛)

## 这次补充我想提一下循环结构复习的一些东西，还有缓冲区的问题
----------------------------------------------------
#### 三大循环结构：for,while和do-while

其中，for与while本质上是等价的，怎么解释呢？

我们先想一下完成一个循环所需要的三个行为：

* 初始化表达式：用来作为一个循环的初始次数，一般是0，注意这个表达式不要放到循环体里面！（不然就是死循环了）

* 测试表达式：用来判断这个循环是否继续执行的表达式，也就是判断循环执行的条件

* 更新表达式：在循环继续执行的时候，用来更新循环执行的次数，这与是否执行下一次循环密切相关

然后我们把这三个条件分别放到for循环与while循环里面比较一下它们的区别：
while循环是这样的：
```c
[初始化表达式];
while ( [测试表达式] ) {
...... （此处省略n行代码）
[更新表达式];
}
```
for 循环是这样的：
```c
for ( [初始化表达式]; [循环表达式]; [更新表达式] ) {
...... （此处省略n行代码） 
}
```

可以看到，这俩结构的区别并不大，但是for循环有一个优点，那就是它可以把三个行为写在一起，使得结构上比较紧凑，可以防止漏写或错写其中的表达式，例如，while循环中比较容易犯的一个错误就是把初始化表达式放到循环体里面：
```c
int i;
......
while (i < 10) {
i = 0;		//这个表达式放这里真的好吗?
               ......（此处省略n行代码）
i++;		//更新表达式
}
```
如果你把int i =0这样的初始化表达式放到了循环体里面，那么每次执行循环的时候，判断表达式的值也就永远都在0这个地方徘徊了
如果能像for循环那样放在一起就好了：
```c
int i;
for (i = 0; i < 10; i++) { 		//三个表达式放在一起
...... （此处省略n行代码）
}
```

这样做一目了然，减少的出错的可能性。实际上，通过对for 循环的改造，我们也可以得到与while循环等效的结构：
```c
int i = 0;		//初始化
for (; i <10; ) {		//判断
......（此处省略n行代码）
i++;		//更新
}
```
没错！正常运行情况下，for循环括号中的三个表达式，除了第二项（测试表达式）不能省略之外，其他的两个表达式都是可选的，只需要把它们放在正确的位置上就可以了，但是要记住，**不管有没有表达式，两个分号是绝对不能省略的！**

比如说，我想写一个死循环，可以这么写：
```c
for ( ; ; ) {	//注意一下这里的分号，并没有省略
printf("不要停下来啊！\n");
}		
//p.s. 若省略了第二个判断表达式，编译器默认为true
```
只要循环体内的语句不包含能够跳出循环的语句（比如break），那么这个循环就会一直执行下去，就会一直执行printf语句（~~道路就会不断的延伸......~~）  

![00.jpg](https://gitee.com/szleaves/C-Practise/raw/master/keywords_log/pictures/2020_03_27remark/00.jpg)
![01.jpg](https://gitee.com/szleaves/C-Practise/raw/master/keywords_log/pictures/2020_03_27remark/01.jpg)

>p.s. 在机器配置低的设备上运行死循环极有可能造成系统死机

**但是如果你漏掉了分号，编译器就会报错，指出这是一个语法错误**


**实际上for循环是一个灵活性很高的循环结构，如果你愿意，甚至可以用逗号操作符把一个循环的语句全部写到for()的括号里面**

在for循环括号中的第三个表达式，实际上可以是任意合法的表达式：
举个栗子（这是我们上次写的数字排序循环的其中一种方法）：
```c
k1 = 1;  k2 = 10000;  temp = 0;
while (t3 != 0) {
	temp = t3 % 10;
	p1 += (temp * k1);
	p2 += (temp * k2);
	t3 /= 10;  k1 *= 10;  k2 /= 10;
}
```

用上for循环和逗号运算符来连接表达式，就可以写成这样了：
（注意分号的位置）
```c
for (temp = 0,k1 = 1, k2 = 10000; t3 != 0; k1 *= 10, k2 /= 10, temp = t3 % 10;) {
	p1 += (temp * k1);
	p2 += (temp * k2);
	t3 /= 10;
	}
```

通过在第三个表达式的位置添加语句，可以适当的改造循环的主体结构，使得循环体更容易能理解，与while相比确实紧凑了不少!

最后介绍一下do-while语句，作为出口循环，它可以先执行操作，后判断，格式如下：
```c
[初始化表达式];
do {
.....
.....（此处省略n行代码）
[更新表达式];
} while ( [测试表达式] );
```
1.这里同样要注意，初始化表达式不能写在do-while结构内！  
2.此外，注意这个结果的书写格式，结尾的while后面要跟上分号  
3.如果只有一条语句，花括号也是可以不用加的  
4.使用do-while循环有时候可以减少一些重复的代码，例如：
（实验五第六题(1)，重复验证答案）

```c
do {
	printf("--Wrong! Please try again! \n"
		   "%d * %d = ", *a, *b);
	while (getchar() != '\n') 	//刷新缓冲区
		continue;
	} while (0 == scanf("%d", &w_res) || w_res != (*a) * (*b));
```
如果用while循环就要这么写：
```c
printf("--Wrong! Please try again! \n"      "%d * %d = ", *a, *b);  	//多加的部分
	while (0 == scanf("%d", &w_res) || w_res != (*a) * (*b)) {
	printf("--Wrong! Please try again! \n"
		   "%d * %d = ", *a, *b);
	while (getchar() != '\n') 	//刷新缓冲区
		continue;
	}
```
与do-while相比，我们需要多加上一句printf输出才能达到一样的效果。   
5.由于do-while 是先执行，后判断，所以循环体至少会被执行一次，此时要注意你的循环体内有哪些东西是不需要至少被执行一次的，如果有，就应该安排好它的位置，否则就换用while或者for循环
比如说下面这个验证用户密码的程序（伪代码描述）：
```c
do {
提示用户输入密码;
验证用户输入密码;
.....
} while ( 用户输入的密码不正确 );
```
上面这样写没有问题，但是如果你想在while之前加上一些其他功能：
```c
do {
.....
提示用户是否继续输入密码;
[其他功能];
.....
} while ( 回答Yes );
```
这样写的话，用户输入之后，循环还会被执行一遍来判断用户输入的是什么信息，然后__[其他功能]__还会再执行一遍，因为这个时候测试条件已经晚了，这里一定要避免这样的用法

那么在实际使用的时候要如何确定使用哪一种循环呢？大家已经学过了，**for循环更适合已知初始化次数和更新变量的循环结构，而while循环更适合”不确定性“循环，do-while适合那些至少被执行一次的循环结构。**

实际上针对入口循环而言，for和while两者的效果都是一样的，可以看个人喜好，最好看程序的要求来选择。一般来说，入口循环与出口循环相比，由于表达式和条件放在头部，可读性较高，而且大部分场合下，入口循环使用的会比较多（即先判断，后执行）。具体如何操作，还是要看各位自己如何设计这个程序了  
编程中的一个原则就是代码保持简洁易懂，如果这部分的功能使用某种写法过于复杂且难以维护，那就换用另外一种写法。同理，如果你认为这种类型的循环结构会增加代码量，那就换一种循环结构使用（比如上文所述的使用do-while和while的区别）

--------------------------------------------------------
### 缓冲区与换行符
缓冲区的涉及到C语言输入函数的基本工作原理了：
实际上，对于实验五的第五题，如果不采用循环的话，也许大家会很难注意到这个问题的吧，有一位同学的代码就是这么写的：
```c
（以下为核心部分）
	 .....（省略开头）
    int a, b, res, ans;
    float r = 0, t = 0;
	 char c;    
    do
    {
     ......（省略获取随机数过程）
   printf("%d*%d=?请输入你的答案:\n", a, b);
        scanf("%d", &res);
        ans = a*b;
        if(ans == res)
        {
            printf("Right!\n");
            r++;
        }
        else
        {
            printf("Wrong!\n");
        }
        printf("是否继续答题？(继续答题请输入Y，退出答题请输入N)\n");
        scanf("%c", &c);
    }
    while(c == 'Y');
    printf("共做了%.0f题，做对了%.0f题\n总分是%.1f分\n", t, r, r/t*100);
printf("程序结束");
 ......（省略结尾）
```
结果是这样的：  

![02.jpg](https://gitee.com/szleaves/C-Practise/raw/master/keywords_log/pictures/2020_03_27remark/02.jpg)

还没有等我们输入Y或者N确认，程序就结束了！  
这个问题就是换行符的问题了，还记得scanf()函数的读取规则吗？

**scanf()只会读取与转换说明相对应的数据类型，其余不是这个数据类型的东西都会被scanf()抛弃**

当你在使用键盘输入的时候，你输入的东西并不会直接被存储到某个数据类型中，而是会存在于缓冲区之中。当然，这个方式是对于有缓冲输入来说的。
键盘输入有两种类型来读取数据，缓冲输入和无缓冲输入，顾名思义，它们两者区别就是是否使用了缓冲区(buffer)，大家可以动手运行一下下面的这两个程序（到github上copy一下代码）

>有缓冲输入：https://github.com/SzLeaves/C-Practise/blob/master/C8/buffer.c

>无缓冲输入：
https://github.com/SzLeaves/C-Practise/blob/master/C8/non-buffer.c

在没有缓冲输入的程序中，只要键盘接收了一个字符，就会立即输出到屏幕上，这种特性在文字输入的时候是不大友好的。  
首先，有了缓冲区，你输入的东西可以作为一个块（block）发送给计算机，这比逐字符传输要快得多，第二，有缓冲输入可以在我们输入错误的时候让我们有更正输入的机会，这就是为什么在使用缓冲输入的时候如果你打错了数字或字符，还可以删掉重新输入的原因。  
仔细看下图，如果你的输入没有被输入函数所读取，它不会凭空消失，而是会一直留在你的缓冲区里！  
![03.jpg](https://gitee.com/szleaves/C-Practise/raw/master/keywords_log/pictures/2020_03_27remark/03.jpg)

当然了，无缓冲输入也有用武之地，例如一个游戏在读取玩家在键盘上按下的按键时，就不需要缓冲区了，因为按下按键是立即可以响应某个动作的。上面无缓冲输入的代码示例，其实原理上个跟大家玩的需要按键响应的游戏是一致的。

但是有缓冲输入也会造成一个很麻烦的事情，就是响应按键操作的时候，程序也会把对应操作的字符（如果有的话）读进缓冲区，比如刚刚的换行符（\n），这个东西一般是我们不需要的。实际上，每一次使用输入函数（不止是scanf()）从键盘输入的时候都会发生这样 事情，大家也不用觉得太奇怪，不只是循环，如果你在一个从上往下执行的程序中依次使用了两个以上的scanf()语句，也会发生这种问题。  
解决这个问题的办法就是：刷新缓冲区  
**仅仅只是清空一个换行符的话，最简单的办法就是添加一行getchar()语句：**

```c
......
scanf("%d", &a);
getchar();		//清除换行符
......
```

getchar()函数的作用是用来读取1个字符（注意是1个字符！不是字符串！），按照转换类型scanf()函数只会读取一个数值，不会读取换行符，所以它能够帮我们把缓冲区里剩余的换行符给读取了，当然，换行符虽然被读取了，但它并没有存储进任何一个已知变量中。  
但是大家要知道，使用程序的用户不一定会老老实实的按照你写的程序来输入数据的，他们可能会在键盘上乱按，然后按下回车键来让你的程序处理这么一堆字符，比如说我们实验上的让小学生做乘法练习的题目，某个暴躁的小学生在输入答案的时候可能会这样做，拿这个程序撒气：  

![04.jpg](https://gitee.com/szleaves/C-Practise/raw/master/keywords_log/pictures/2020_03_27remark/04.jpg)

如果你在这里设计了一个循环，希望让程序反复读取这个小学生输入的正确答案的话，你的程序就暴走了（陷入无限循环）：

![05.jpg](https://gitee.com/szleaves/C-Practise/raw/master/keywords_log/pictures/2020_03_27remark/05.jpg)

为啥上面我们所使用的清空缓冲区的方法不管用了呢？  

原因是：我们上面所介绍的情况只适用于清空缓冲区中一个多余的字符，但如果缓冲区中有一堆字符的话（比如像上面那个小学生的输入），**getchar()只会执行一次**  ，也就是说，它只会读取一个字符，剩余的字符依旧在缓冲区中待着，所以在下一次执行循环体的时候造成了这样的问题。由于缓冲区是一直有东西的，所以scanf()会不停地跳过输入，程序就这样陷入了死循环  

不过解决问题的方法也很简单，既然getchar()一次读取一个，那我们让它多读取几次不就可以了吗？所以我们给getchar()加个循环：
```c
while (getchar() != '\n')
		continue;
```
**这个循环大家可以记一下，以后清空缓冲区很有用**

请看while的判断条件：
```c
getchar() != '\n'
```
在getchar()读取到的字符不是换行符之前，这个循环将一直执行下去，直到getchar()读取到换行符为止，这样做，我们就可以把上面那个小学生乱七八糟的输入给统统丢掉了，由于要进行字符之间的判断，所以在判断之前，缓冲区里的字符就已经被getchar()给读取了，所以两行代码就可以起到清空缓冲区的作用了！
实际上你也可以写成这样：
```c
while (getchar() != '\n') ; 		//注意后面的分号
```
while()后面有一个分号，单独的一个分号表示的是一个空语句，它什么事都不干，所以跟在这里可以跟continue起到一样的效果

但是这样做有个缺点，就是分号不大明显，而且比较容易被遗忘或者漏看，站在维护性和代码语义性的角度看，还是加上continue会比较合适  
![06.jpg](https://gitee.com/szleaves/C-Practise/raw/master/keywords_log/pictures/2020_03_27remark/06.jpg)
